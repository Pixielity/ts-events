{"version":3,"sources":["../../src/constants/metadata.constants.ts","../../src/decorators/event.decorator.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAGO,IAAM,mBAAsB,GAAA,gBAAA;;;ACwC5B,SAAS,KAAA,CAAM,OAAwB,GAAA,EAAoB,EAAA;AAChE,EAAA,OAAO,CAAC,MAA2B,KAAA;AAEjC,IAAQ,OAAA,CAAA,cAAA;AAAA,MACN,mBAAA;AAAA,MACA;AAAA,QACE,IAAA,EAAM,OAAQ,CAAA,IAAA,IAAQ,MAAO,CAAA,IAAA;AAAA,QAC7B,SAAA,EAAW,QAAQ,SAAa,IAAA,KAAA;AAAA,QAChC,QAAA,EAAU,OAAQ,CAAA,QAAA,IAAY,EAAC;AAAA,QAC/B;AAAA,OACF;AAAA,MACA;AAAA,KACF;AAGA,IAAI,IAAA,CAAC,MAAO,CAAA,SAAA,CAAU,YAAc,EAAA;AAClC,MAAA,MAAA,CAAO,SAAU,CAAA,YAAA,GAAe,MAAM,OAAA,CAAQ,QAAQ,MAAO,CAAA,IAAA;AAAA;AAG/D,IAAA,IAAI,CAAC,MAAO,CAAA,SAAA,CAAU,eAAmB,IAAA,OAAA,CAAQ,cAAc,MAAW,EAAA;AACxE,MAAO,MAAA,CAAA,SAAA,CAAU,eAAkB,GAAA,MAAM,OAAQ,CAAA,SAAA;AAAA;AAGnD,IAAA,IAAI,CAAC,MAAA,CAAO,SAAU,CAAA,WAAA,IAAe,QAAQ,QAAU,EAAA;AACrD,MAAO,MAAA,CAAA,SAAA,CAAU,WAAc,GAAA,MAAM,OAAQ,CAAA,QAAA;AAAA;AAC/C,GACF;AACF","file":"event.decorator.js","sourcesContent":["/**\n * Metadata key for event information.\n */\nexport const EVENTS_METADATA_KEY = 'tsevents:event'\n\n/**\n * Metadata key for listener information.\n */\nexport const LISTENERS_METADATA_KEY = 'tsevents:listener'\n\n/**\n * Metadata key for subscriber information.\n */\nexport const SUBSCRIBERS_METADATA_KEY = 'tsevents:subscriber'\n\n/**\n * Metadata key for queueable information.\n */\nexport const QUEUEABLE_METADATA_KEY = 'tsevents:queueable'\n","import 'reflect-metadata'\nimport { EVENTS_METADATA_KEY } from '../constants/metadata.constants'\n\n/**\n * Options for the Event decorator.\n */\nexport interface EventOptions {\n  /**\n   * The name of the event. If not provided, the class name will be used.\n   */\n  name?: string\n\n  /**\n   * Whether the event should be broadcast.\n   */\n  broadcast?: boolean\n\n  /**\n   * The channels to broadcast on.\n   */\n  channels?: string[]\n}\n\n/**\n * Decorator that marks a class as an event.\n *\n * @param {EventOptions} [options] - Options for the event\n * @returns {ClassDecorator} The decorator function\n *\n * @example\n * \\`\\`\\`typescript\n * @Event()\n * class UserCreated implements IEvent {\n *   constructor(public readonly userId: string) {}\n * }\n *\n * // With options\n * @Event({ name: 'user.created', broadcast: true, channels: ['users'] })\n * class UserCreated implements IEvent {\n *   constructor(public readonly userId: string) {}\n * }\n * \\`\\`\\`\n */\nexport function Event(options: EventOptions = {}): ClassDecorator {\n  return (target: Function): void => {\n    // Store event metadata\n    Reflect.defineMetadata(\n      EVENTS_METADATA_KEY,\n      {\n        name: options.name || target.name,\n        broadcast: options.broadcast || false,\n        channels: options.channels || [],\n        target,\n      },\n      target,\n    )\n\n    // Add default implementations if not provided\n    if (!target.prototype.getEventName) {\n      target.prototype.getEventName = () => options.name || target.name\n    }\n\n    if (!target.prototype.shouldBroadcast && options.broadcast !== undefined) {\n      target.prototype.shouldBroadcast = () => options.broadcast\n    }\n\n    if (!target.prototype.broadcastOn && options.channels) {\n      target.prototype.broadcastOn = () => options.channels\n    }\n  }\n}\n"]}