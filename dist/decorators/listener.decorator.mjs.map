{"version":3,"sources":["../../../../../../node_modules/inversify/es/constants/metadata_keys.js","../../../../../../node_modules/inversify/es/constants/error_msgs.js","../../../../../../node_modules/inversify/es/annotation/injectable.js","../../src/constants/metadata.constants.ts","../../src/decorators/listener.decorator.ts"],"names":[],"mappings":";;;;;;;;;;;AAQO,IAAI,WAAc,GAAA,sBAAA;AAClB,IAAI,kBAAqB,GAAA,mBAAA;;;ACTzB,IAAI,+BAAkC,GAAA,oDAAA;;;ACE7C,SAAS,UAAa,GAAA;AAClB,EAAA,OAAO,SAAU,MAAQ,EAAA;AACrB,IAAA,IAAI,OAAQ,CAAA,cAAA,CAA4B,WAAa,EAAA,MAAM,CAAG,EAAA;AAC1D,MAAM,MAAA,IAAI,MAAkB,+BAA+B,CAAA;AAAA;AAE/D,IAAA,IAAI,QAAQ,OAAQ,CAAA,WAAA,CAAyB,kBAAoB,EAAA,MAAM,KAAK,EAAC;AAC7E,IAAQ,OAAA,CAAA,cAAA,CAA4B,WAAa,EAAA,KAAA,EAAO,MAAM,CAAA;AAC9D,IAAO,OAAA,MAAA;AAAA,GACX;AACJ;;;ACHO,IAAM,sBAAyB,GAAA,mBAAA;;;ACmD/B,SAAS,SAAS,OAA0C,EAAA;AACjE,EAAA,OAAO,CAAC,MAA0B,KAAA;AAEhC,IAAA,UAAA,GAAa,MAAa,CAAA;AAE1B,IAAM,MAAA,MAAA,GAAS,KAAM,CAAA,OAAA,CAAQ,OAAQ,CAAA,KAAK,IAAI,OAAQ,CAAA,KAAA,GAAQ,CAAC,OAAA,CAAQ,KAAK,CAAA;AAG5E,IAAQ,OAAA,CAAA,cAAA;AAAA,MACN,sBAAA;AAAA,MACA;AAAA,QACE,MAAA;AAAA,QACA,MAAA,EAAQ,QAAQ,MAAU,IAAA,KAAA;AAAA,QAC1B,KAAA,EAAO,QAAQ,KAAS,IAAA,CAAA;AAAA,QACxB,UAAA,EAAY,QAAQ,UAAc,IAAA,IAAA;AAAA,QAClC,KAAA,EAAO,QAAQ,KAAS,IAAA,IAAA;AAAA,QACxB;AAAA,OACF;AAAA,MACA;AAAA,KACF;AAGA,IAAA,IAAI,QAAQ,MAAQ,EAAA;AAClB,MAAI,IAAA,CAAC,MAAO,CAAA,SAAA,CAAU,WAAa,EAAA;AACjC,QAAO,MAAA,CAAA,SAAA,CAAU,cAAc,MAAM,IAAA;AAAA;AAGvC,MAAI,IAAA,CAAC,MAAO,CAAA,SAAA,CAAU,UAAY,EAAA;AAChC,QAAA,MAAA,CAAO,SAAU,CAAA,UAAA,GAAa,MAAM,OAAA,CAAQ,UAAc,IAAA,IAAA;AAAA;AAG5D,MAAI,IAAA,CAAC,MAAO,CAAA,SAAA,CAAU,KAAO,EAAA;AAC3B,QAAA,MAAA,CAAO,SAAU,CAAA,KAAA,GAAQ,MAAM,OAAA,CAAQ,KAAS,IAAA,IAAA;AAAA;AAGlD,MAAI,IAAA,CAAC,MAAO,CAAA,SAAA,CAAU,KAAO,EAAA;AAC3B,QAAA,MAAA,CAAO,SAAU,CAAA,KAAA,GAAQ,MAAM,OAAA,CAAQ,KAAS,IAAA,CAAA;AAAA;AAClD;AAGF,IAAO,OAAA,MAAA;AAAA,GACT;AACF","file":"listener.decorator.mjs","sourcesContent":["export var NAMED_TAG = 'named';\r\nexport var NAME_TAG = 'name';\r\nexport var UNMANAGED_TAG = 'unmanaged';\r\nexport var OPTIONAL_TAG = 'optional';\r\nexport var INJECT_TAG = 'inject';\r\nexport var MULTI_INJECT_TAG = 'multi_inject';\r\nexport var TAGGED = 'inversify:tagged';\r\nexport var TAGGED_PROP = 'inversify:tagged_props';\r\nexport var PARAM_TYPES = 'inversify:paramtypes';\r\nexport var DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nexport var POST_CONSTRUCT = 'post_construct';\r\nexport var PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nexport var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n","export var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nexport var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nexport var NULL_ARGUMENT = 'NULL argument';\r\nexport var KEY_NOT_FOUND = 'Key Not Found';\r\nexport var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nexport var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nexport var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nexport var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nexport var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nexport var UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nexport var CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nexport var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nexport var INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nexport var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nexport var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nexport var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nexport var LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nexport var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nexport var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nexport var ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nexport var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nexport var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nexport var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nexport var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nexport var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nexport var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nexport var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nexport var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nexport var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nexport var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nexport var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nexport var STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n","import * as ERRORS_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nfunction injectable() {\r\n    return function (target) {\r\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {\r\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\r\n        }\r\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\r\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\r\n        return target;\r\n    };\r\n}\r\nexport { injectable };\r\n","/**\n * Metadata key for event information.\n */\nexport const EVENTS_METADATA_KEY = 'tsevents:event'\n\n/**\n * Metadata key for listener information.\n */\nexport const LISTENERS_METADATA_KEY = 'tsevents:listener'\n\n/**\n * Metadata key for subscriber information.\n */\nexport const SUBSCRIBERS_METADATA_KEY = 'tsevents:subscriber'\n\n/**\n * Metadata key for queueable information.\n */\nexport const QUEUEABLE_METADATA_KEY = 'tsevents:queueable'\n","import 'reflect-metadata'\nimport { injectable } from 'inversify'\nimport { LISTENERS_METADATA_KEY } from '../constants/metadata.constants'\nimport type { IEvent } from '@pixielity/ts-types'\n\n/**\n * Options for the Listener decorator.\n */\nexport interface ListenerOptions {\n  /**\n   * The event(s) to listen for. Can be a string event name or an IEvent class.\n   */\n  event: string | (new (...args: any[]) => IEvent) | (string | (new (...args: any[]) => IEvent))[]\n\n  /**\n   * Whether the listener should be queued.\n   */\n  queued?: boolean\n\n  /**\n   * The delay in seconds before processing the listener (if queued).\n   */\n  delay?: number\n\n  /**\n   * The queue connection to use (if queued).\n   */\n  connection?: string\n\n  /**\n   * The queue to use (if queued).\n   */\n  queue?: string\n}\n\n/**\n * Decorator that marks a class as an event listener.\n *\n * @param {ListenerOptions} options - Options for the listener\n * @returns {ClassDecorator} The decorator function\n *\n * @example\n * \\`\\`\\`typescript\n * @Listener({ event: UserCreated })\n * class SendWelcomeEmail implements IListener<UserCreated> {\n *   handle(event: UserCreated): void {\n *     // Send welcome email logic\n *   }\n * }\n *\n * // With multiple events\n * @Listener({ event: [UserCreated, UserActivated], queued: true, delay: 60 })\n * class NotifyAdminOfUserActivity implements IListener {\n *   handle(event: IEvent): void {\n *     // Notify admin logic\n *   }\n * }\n * \\`\\`\\`\n */\nexport function Listener(options: ListenerOptions): ClassDecorator {\n  return (target: Function): any => {\n    // Apply injectable decorator\n    injectable()(target as any)\n\n    const events = Array.isArray(options.event) ? options.event : [options.event]\n\n    // Store listener metadata\n    Reflect.defineMetadata(\n      LISTENERS_METADATA_KEY,\n      {\n        events,\n        queued: options.queued || false,\n        delay: options.delay || 0,\n        connection: options.connection || null,\n        queue: options.queue || null,\n        target,\n      },\n      target,\n    )\n\n    // If queued, implement ShouldQueue interface methods\n    if (options.queued) {\n      if (!target.prototype.shouldQueue) {\n        target.prototype.shouldQueue = () => true\n      }\n\n      if (!target.prototype.connection) {\n        target.prototype.connection = () => options.connection || null\n      }\n\n      if (!target.prototype.queue) {\n        target.prototype.queue = () => options.queue || null\n      }\n\n      if (!target.prototype.delay) {\n        target.prototype.delay = () => options.delay || 0\n      }\n    }\n\n    return target\n  }\n}\n"]}