{"version":3,"sources":["../../../../../node_modules/inversify/es/constants/metadata_keys.js","../../../../../node_modules/inversify/es/constants/error_msgs.js","../../../../../node_modules/inversify/es/planning/metadata.js","../../../../../node_modules/inversify/es/utils/js.js","../../../../../node_modules/inversify/es/annotation/decorator_utils.js","../../../../../node_modules/inversify/es/annotation/inject_base.js","../../../../../node_modules/inversify/es/annotation/inject.js","../../src/utils/reflection.util.ts","../../src/commands/event-command.ts"],"names":["Metadata","m","EventCommand","BaseCommand","Option","Command","IEventDispatcher","IQueueManager"],"mappings":"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","file":"event-command.js","sourcesContent":["export var NAMED_TAG = 'named';\r\nexport var NAME_TAG = 'name';\r\nexport var UNMANAGED_TAG = 'unmanaged';\r\nexport var OPTIONAL_TAG = 'optional';\r\nexport var INJECT_TAG = 'inject';\r\nexport var MULTI_INJECT_TAG = 'multi_inject';\r\nexport var TAGGED = 'inversify:tagged';\r\nexport var TAGGED_PROP = 'inversify:tagged_props';\r\nexport var PARAM_TYPES = 'inversify:paramtypes';\r\nexport var DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nexport var POST_CONSTRUCT = 'post_construct';\r\nexport var PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nexport var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n","export var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nexport var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nexport var NULL_ARGUMENT = 'NULL argument';\r\nexport var KEY_NOT_FOUND = 'Key Not Found';\r\nexport var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nexport var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nexport var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nexport var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nexport var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nexport var UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nexport var CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nexport var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nexport var INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nexport var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nexport var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nexport var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nexport var LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nexport var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nexport var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nexport var ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nexport var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nexport var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nexport var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nexport var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nexport var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nexport var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nexport var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nexport var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nexport var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nexport var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nexport var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nexport var STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nvar Metadata = (function () {\r\n    function Metadata(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    Metadata.prototype.toString = function () {\r\n        if (this.key === METADATA_KEY.NAMED_TAG) {\r\n            return \"named: \" + String(this.value).toString() + \" \";\r\n        }\r\n        else {\r\n            return \"tagged: { key:\" + this.key.toString() + \", value: \" + String(this.value) + \" }\";\r\n        }\r\n    };\r\n    return Metadata;\r\n}());\r\nexport { Metadata };\r\n","export function getFirstArrayDuplicate(array) {\r\n    var seenValues = new Set();\r\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n        var entry = array_1[_i];\r\n        if (seenValues.has(entry)) {\r\n            return entry;\r\n        }\r\n        else {\r\n            seenValues.add(entry);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n","import * as ERROR_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { getFirstArrayDuplicate } from '../utils/js';\r\nfunction targetIsConstructorFunction(target) {\r\n    return target.prototype !== undefined;\r\n}\r\nfunction _throwIfMethodParameter(parameterName) {\r\n    if (parameterName !== undefined) {\r\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\r\n    }\r\n}\r\nfunction tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {\r\n    _throwIfMethodParameter(parameterName);\r\n    _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);\r\n}\r\nfunction tagProperty(annotationTarget, propertyName, metadata) {\r\n    if (targetIsConstructorFunction(annotationTarget)) {\r\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\r\n    }\r\n    _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);\r\n}\r\nfunction _ensureNoMetadataKeyDuplicates(metadata) {\r\n    var metadatas = [];\r\n    if (Array.isArray(metadata)) {\r\n        metadatas = metadata;\r\n        var duplicate = getFirstArrayDuplicate(metadatas.map(function (md) { return md.key; }));\r\n        if (duplicate !== undefined) {\r\n            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + duplicate.toString());\r\n        }\r\n    }\r\n    else {\r\n        metadatas = [metadata];\r\n    }\r\n    return metadatas;\r\n}\r\nfunction _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {\r\n    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);\r\n    var paramsOrPropertiesMetadata = {};\r\n    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {\r\n        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);\r\n    }\r\n    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];\r\n    if (paramOrPropertyMetadata === undefined) {\r\n        paramOrPropertyMetadata = [];\r\n    }\r\n    else {\r\n        var _loop_1 = function (m) {\r\n            if (metadatas.some(function (md) { return md.key === m.key; })) {\r\n                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + m.key.toString());\r\n            }\r\n        };\r\n        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {\r\n            var m = paramOrPropertyMetadata_1[_i];\r\n            _loop_1(m);\r\n        }\r\n    }\r\n    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);\r\n    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;\r\n    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);\r\n}\r\nfunction createTaggedDecorator(metadata) {\r\n    return function (target, targetKey, indexOrPropertyDescriptor) {\r\n        if (typeof indexOrPropertyDescriptor === 'number') {\r\n            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);\r\n        }\r\n        else {\r\n            tagProperty(target, targetKey, metadata);\r\n        }\r\n    };\r\n}\r\nfunction _decorate(decorators, target) {\r\n    Reflect.decorate(decorators, target);\r\n}\r\nfunction _param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); };\r\n}\r\nfunction decorate(decorator, target, parameterIndexOrProperty) {\r\n    if (typeof parameterIndexOrProperty === 'number') {\r\n        _decorate([_param(parameterIndexOrProperty, decorator)], target);\r\n    }\r\n    else if (typeof parameterIndexOrProperty === 'string') {\r\n        Reflect.decorate([decorator], target, parameterIndexOrProperty);\r\n    }\r\n    else {\r\n        _decorate([decorator], target);\r\n    }\r\n}\r\nexport { decorate, tagParameter, tagProperty, createTaggedDecorator };\r\n","import { UNDEFINED_INJECT_ANNOTATION } from '../constants/error_msgs';\r\nimport { Metadata } from '../planning/metadata';\r\nimport { createTaggedDecorator } from './decorator_utils';\r\nexport function injectBase(metadataKey) {\r\n    return function (serviceIdentifier) {\r\n        return function (target, targetKey, indexOrPropertyDescriptor) {\r\n            if (serviceIdentifier === undefined) {\r\n                var className = typeof target === 'function' ? target.name : target.constructor.name;\r\n                throw new Error(UNDEFINED_INJECT_ANNOTATION(className));\r\n            }\r\n            return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);\r\n        };\r\n    };\r\n}\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { injectBase } from './inject_base';\r\nvar inject = injectBase(METADATA_KEY.INJECT_TAG);\r\nexport { inject };\r\n","import 'reflect-metadata'\nimport type { IEvent } from '@pixielity/ts-types'\n\nimport { EVENTS_METADATA_KEY } from '../constants/metadata.constants'\n\n/**\n * Get the event name from an event object or class.\n *\n * @param {Event | Function} event - The event object or class\n * @returns {string} The event name\n */\nexport function getEventName(event: IEvent | Function): string {\n  // If it's an instance with getEventName method, use that\n  if (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as IEvent).getEventName === 'function'\n  ) {\n    return (event as IEvent).getEventName!()\n  }\n\n  // Get the constructor (if it's an instance) or the class itself\n  const target = typeof event === 'object' ? event.constructor : event\n\n  // Check for metadata\n  const metadata = Reflect.getMetadata(EVENTS_METADATA_KEY, target)\n  if (metadata && metadata.name) {\n    return metadata.name\n  }\n\n  // Fallback to class name\n  return target.name\n}\n\n// Registry to track decorated event classes\nconst eventRegistry: Function[] = []\n\n/**\n * Register an event class in the registry.\n * This is called by the Event decorator.\n *\n * @param eventClass - The event class to register\n */\nexport function registerEventClass(eventClass: Function): void {\n  if (!eventRegistry.includes(eventClass)) {\n    eventRegistry.push(eventClass)\n  }\n}\n\n/**\n * Get all registered event classes.\n *\n * @returns {Function[]} Array of event classes\n */\nexport function getEventClasses(): Function[] {\n  return [...eventRegistry]\n}\n\n/**\n * Check if a class is an event.\n *\n * @param {Function} target - The class to check\n * @returns {boolean} True if the class is an event\n */\nexport function isEvent(target: Function): boolean {\n  return Reflect.hasMetadata(EVENTS_METADATA_KEY, target)\n}\n","import { injectable, inject } from 'inversify'\nimport { BaseCommand, Command, Option } from '@pixielity/ts-console'\nimport { IEventDispatcher, IQueueConnection, IQueueManager } from '@pixielity/ts-types'\n\nimport { getEventClasses } from '../utils/reflection.util'\n\n/**\n * Command for managing events and queues.\n */\n@Command({\n  name: 'event',\n  description: 'Manage events and event listeners',\n  shortcuts: [\n    {\n      flag: '-e',\n      description: 'Manage events and event listeners',\n    },\n  ],\n})\nexport class EventCommand extends BaseCommand {\n  /**\n   * The uppercase option\n   */\n  @Option({\n    flags: '-c, --command',\n    description: 'The sub command to call',\n  })\n  private command!: boolean\n\n  /**\n   * Creates a new EventCommand instance.\n   *\n   * @param dispatcher - The event dispatcher\n   * @param queueManager - The queue manager\n   */\n  constructor(\n    @inject(IEventDispatcher.$) private dispatcher: IEventDispatcher,\n    @inject(IQueueManager.$) private queueManager: IQueueManager,\n  ) {\n    super()\n  }\n\n  /**\n   * Configure the command.\n   */\n  public configure(): void {\n    // Command configuration would go here\n    // For example, defining arguments and options\n  }\n\n  /**\n   * Executes the command\n   *\n   * This method must be implemented by subclasses to provide\n   * command-specific functionality.\n   *\n   * @returns {Promise<number | void>} The exit code or void\n   */\n  public async execute(): Promise<number | void> {\n    const subCommand = this.getArgument('command') || 'list'\n\n    switch (subCommand) {\n      case 'list':\n        return this.listEvents()\n      case 'process':\n      // return this.processQueue(context.args[1])\n      case 'clear':\n      // return this.clearQueue(context.args[1])\n      default:\n        this.error(`Unknown subcommand: ${subCommand}`)\n        return 1\n    }\n  }\n\n  /**\n   * List all registered events.\n   */\n  private async listEvents(): Promise<void> {\n    const events = getEventClasses()\n\n    if (events.length === 0) {\n      this.info('No events registered')\n      return\n    }\n\n    this.info('Registered events:')\n\n    for (const eventClass of events) {\n      this.line(` - ${eventClass.name}`)\n    }\n  }\n\n  /**\n   * Process jobs in a queue.\n   *\n   * @param queue - The queue to process\n   */\n  private async processQueue(queue?: string): Promise<void> {\n    try {\n      const connection = this.queueManager.connection() as IQueueConnection\n\n      if (!connection.process) {\n        this.error('The current queue connection does not support processing')\n        return\n      }\n\n      this.info(`Processing queue: ${queue || 'default'}`)\n      await connection.process(queue)\n      this.success('Queue processed successfully')\n    } catch (error) {\n      this.error(\n        `Error processing queue: ${error instanceof Error ? error.message : String(error)}`,\n      )\n    }\n  }\n\n  /**\n   * Clear jobs in a queue.\n   *\n   * @param queue - The queue to clear\n   */\n  private async clearQueue(queue?: string): Promise<void> {\n    try {\n      const connection = this.queueManager.connection() as IQueueConnection\n\n      if (!connection.clear) {\n        this.error('The current queue connection does not support clearing')\n        return\n      }\n\n      this.info(`Clearing queue: ${queue || 'default'}`)\n      connection.clear(queue)\n      this.success('Queue cleared successfully')\n    } catch (error) {\n      this.error(`Error clearing queue: ${error instanceof Error ? error.message : String(error)}`)\n    }\n  }\n}\n"]}