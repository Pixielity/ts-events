{"version":3,"sources":["../../../../../node_modules/inversify/es/constants/metadata_keys.js","../../../../../node_modules/inversify/es/constants/error_msgs.js","../../../../../node_modules/inversify/es/planning/metadata.js","../../../../../node_modules/inversify/es/utils/js.js","../../../../../node_modules/inversify/es/annotation/decorator_utils.js","../../../../../node_modules/inversify/es/annotation/injectable.js","../../../../../node_modules/inversify/es/annotation/inject_base.js","../../../../../node_modules/inversify/es/annotation/inject.js","../../../../../node_modules/inversify/es/annotation/optional.js","../src/constants/metadata.constants.ts","../src/utils/reflection.util.ts","../src/event-dispatcher.ts"],"names":["Metadata","m","EventDispatcher","Subject","filter","map"],"mappings":"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","file":"event-dispatcher.js","sourcesContent":["export var NAMED_TAG = 'named';\r\nexport var NAME_TAG = 'name';\r\nexport var UNMANAGED_TAG = 'unmanaged';\r\nexport var OPTIONAL_TAG = 'optional';\r\nexport var INJECT_TAG = 'inject';\r\nexport var MULTI_INJECT_TAG = 'multi_inject';\r\nexport var TAGGED = 'inversify:tagged';\r\nexport var TAGGED_PROP = 'inversify:tagged_props';\r\nexport var PARAM_TYPES = 'inversify:paramtypes';\r\nexport var DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nexport var POST_CONSTRUCT = 'post_construct';\r\nexport var PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nexport var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n","export var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nexport var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nexport var NULL_ARGUMENT = 'NULL argument';\r\nexport var KEY_NOT_FOUND = 'Key Not Found';\r\nexport var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nexport var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nexport var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nexport var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nexport var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nexport var UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nexport var CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nexport var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nexport var INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nexport var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nexport var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nexport var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nexport var LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nexport var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nexport var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nexport var ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nexport var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nexport var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nexport var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nexport var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nexport var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nexport var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nexport var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nexport var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nexport var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nexport var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nexport var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nexport var STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nvar Metadata = (function () {\r\n    function Metadata(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    Metadata.prototype.toString = function () {\r\n        if (this.key === METADATA_KEY.NAMED_TAG) {\r\n            return \"named: \" + String(this.value).toString() + \" \";\r\n        }\r\n        else {\r\n            return \"tagged: { key:\" + this.key.toString() + \", value: \" + String(this.value) + \" }\";\r\n        }\r\n    };\r\n    return Metadata;\r\n}());\r\nexport { Metadata };\r\n","export function getFirstArrayDuplicate(array) {\r\n    var seenValues = new Set();\r\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n        var entry = array_1[_i];\r\n        if (seenValues.has(entry)) {\r\n            return entry;\r\n        }\r\n        else {\r\n            seenValues.add(entry);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n","import * as ERROR_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { getFirstArrayDuplicate } from '../utils/js';\r\nfunction targetIsConstructorFunction(target) {\r\n    return target.prototype !== undefined;\r\n}\r\nfunction _throwIfMethodParameter(parameterName) {\r\n    if (parameterName !== undefined) {\r\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\r\n    }\r\n}\r\nfunction tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {\r\n    _throwIfMethodParameter(parameterName);\r\n    _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);\r\n}\r\nfunction tagProperty(annotationTarget, propertyName, metadata) {\r\n    if (targetIsConstructorFunction(annotationTarget)) {\r\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\r\n    }\r\n    _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);\r\n}\r\nfunction _ensureNoMetadataKeyDuplicates(metadata) {\r\n    var metadatas = [];\r\n    if (Array.isArray(metadata)) {\r\n        metadatas = metadata;\r\n        var duplicate = getFirstArrayDuplicate(metadatas.map(function (md) { return md.key; }));\r\n        if (duplicate !== undefined) {\r\n            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + duplicate.toString());\r\n        }\r\n    }\r\n    else {\r\n        metadatas = [metadata];\r\n    }\r\n    return metadatas;\r\n}\r\nfunction _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {\r\n    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);\r\n    var paramsOrPropertiesMetadata = {};\r\n    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {\r\n        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);\r\n    }\r\n    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];\r\n    if (paramOrPropertyMetadata === undefined) {\r\n        paramOrPropertyMetadata = [];\r\n    }\r\n    else {\r\n        var _loop_1 = function (m) {\r\n            if (metadatas.some(function (md) { return md.key === m.key; })) {\r\n                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + m.key.toString());\r\n            }\r\n        };\r\n        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {\r\n            var m = paramOrPropertyMetadata_1[_i];\r\n            _loop_1(m);\r\n        }\r\n    }\r\n    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);\r\n    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;\r\n    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);\r\n}\r\nfunction createTaggedDecorator(metadata) {\r\n    return function (target, targetKey, indexOrPropertyDescriptor) {\r\n        if (typeof indexOrPropertyDescriptor === 'number') {\r\n            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);\r\n        }\r\n        else {\r\n            tagProperty(target, targetKey, metadata);\r\n        }\r\n    };\r\n}\r\nfunction _decorate(decorators, target) {\r\n    Reflect.decorate(decorators, target);\r\n}\r\nfunction _param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); };\r\n}\r\nfunction decorate(decorator, target, parameterIndexOrProperty) {\r\n    if (typeof parameterIndexOrProperty === 'number') {\r\n        _decorate([_param(parameterIndexOrProperty, decorator)], target);\r\n    }\r\n    else if (typeof parameterIndexOrProperty === 'string') {\r\n        Reflect.decorate([decorator], target, parameterIndexOrProperty);\r\n    }\r\n    else {\r\n        _decorate([decorator], target);\r\n    }\r\n}\r\nexport { decorate, tagParameter, tagProperty, createTaggedDecorator };\r\n","import * as ERRORS_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nfunction injectable() {\r\n    return function (target) {\r\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {\r\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\r\n        }\r\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\r\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\r\n        return target;\r\n    };\r\n}\r\nexport { injectable };\r\n","import { UNDEFINED_INJECT_ANNOTATION } from '../constants/error_msgs';\r\nimport { Metadata } from '../planning/metadata';\r\nimport { createTaggedDecorator } from './decorator_utils';\r\nexport function injectBase(metadataKey) {\r\n    return function (serviceIdentifier) {\r\n        return function (target, targetKey, indexOrPropertyDescriptor) {\r\n            if (serviceIdentifier === undefined) {\r\n                var className = typeof target === 'function' ? target.name : target.constructor.name;\r\n                throw new Error(UNDEFINED_INJECT_ANNOTATION(className));\r\n            }\r\n            return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);\r\n        };\r\n    };\r\n}\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { injectBase } from './inject_base';\r\nvar inject = injectBase(METADATA_KEY.INJECT_TAG);\r\nexport { inject };\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { Metadata } from '../planning/metadata';\r\nimport { createTaggedDecorator } from './decorator_utils';\r\nfunction optional() {\r\n    return createTaggedDecorator(new Metadata(METADATA_KEY.OPTIONAL_TAG, true));\r\n}\r\nexport { optional };\r\n","/**\n * Metadata key for event information.\n */\nexport const EVENTS_METADATA_KEY = 'tsevents:event'\n\n/**\n * Metadata key for listener information.\n */\nexport const LISTENERS_METADATA_KEY = 'tsevents:listener'\n\n/**\n * Metadata key for subscriber information.\n */\nexport const SUBSCRIBERS_METADATA_KEY = 'tsevents:subscriber'\n\n/**\n * Metadata key for queueable information.\n */\nexport const QUEUEABLE_METADATA_KEY = 'tsevents:queueable'\n","import 'reflect-metadata'\nimport type { IEvent } from '@pixielity/ts-types'\n\nimport { EVENTS_METADATA_KEY } from '../constants/metadata.constants'\n\n/**\n * Get the event name from an event object or class.\n *\n * @param {Event | Function} event - The event object or class\n * @returns {string} The event name\n */\nexport function getEventName(event: IEvent | Function): string {\n  // If it's an instance with getEventName method, use that\n  if (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as IEvent).getEventName === 'function'\n  ) {\n    return (event as IEvent).getEventName!()\n  }\n\n  // Get the constructor (if it's an instance) or the class itself\n  const target = typeof event === 'object' ? event.constructor : event\n\n  // Check for metadata\n  const metadata = Reflect.getMetadata(EVENTS_METADATA_KEY, target)\n  if (metadata && metadata.name) {\n    return metadata.name\n  }\n\n  // Fallback to class name\n  return target.name\n}\n\n// Registry to track decorated event classes\nconst eventRegistry: Function[] = []\n\n/**\n * Register an event class in the registry.\n * This is called by the Event decorator.\n *\n * @param eventClass - The event class to register\n */\nexport function registerEventClass(eventClass: Function): void {\n  if (!eventRegistry.includes(eventClass)) {\n    eventRegistry.push(eventClass)\n  }\n}\n\n/**\n * Get all registered event classes.\n *\n * @returns {Function[]} Array of event classes\n */\nexport function getEventClasses(): Function[] {\n  return [...eventRegistry]\n}\n\n/**\n * Check if a class is an event.\n *\n * @param {Function} target - The class to check\n * @returns {boolean} True if the class is an event\n */\nexport function isEvent(target: Function): boolean {\n  return Reflect.hasMetadata(EVENTS_METADATA_KEY, target)\n}\n","import type {\n  IEventDispatcher,\n  IEvent,\n  IListener,\n  ISubscriber,\n  IQueueManager,\n} from '@pixielity/ts-types'\nimport { filter, map } from 'rxjs/operators'\nimport { Subject, type Observable } from 'rxjs'\nimport { injectable, inject, optional } from 'inversify'\n\nimport { getEventName } from './utils/reflection.util'\n\n/**\n * Event data structure for the event stream\n */\nexport interface EventData<T = any> {\n  /**\n   * The name of the event\n   */\n  name: string\n\n  /**\n   * The event payload\n   */\n  payload: T\n\n  /**\n   * The timestamp when the event was dispatched\n   */\n  timestamp: number\n}\n\n/**\n * Symbol for the queue manager dependency injection token\n */\nexport const QUEUE_MANAGER_TOKEN = Symbol.for('QueueManager')\n\n/**\n * The main event dispatcher implementation.\n * Responsible for registering listeners and dispatching events.\n * Also provides reactive event handling capabilities.\n */\n@injectable()\nexport class EventDispatcher implements IEventDispatcher {\n  /**\n   * Map of event names to listeners.\n   */\n  private listeners: Map<string, Array<IListener | Function>> = new Map()\n\n  /**\n   * Subject for broadcasting events\n   */\n  private eventSubject = new Subject<EventData>()\n\n  /**\n   * Subject for broadcasting events with name and payload\n   */\n  private eventStreamSubject = new Subject<{ name: string; event: any }>()\n\n  /**\n   * Queue manager instance.\n   */\n  private queueManager?: IQueueManager\n\n  /**\n   * Creates a new EventDispatcher instance.\n   *\n   * @param {QueueManager} [queueManager] - Optional queue manager for queueable events\n   */\n  constructor(@inject(QUEUE_MANAGER_TOKEN) @optional() queueManager?: IQueueManager) {\n    this.queueManager = queueManager\n  }\n\n  /**\n   * [listenerCount description]\n   *\n   * @param   {string}  eventName  [eventName description]\n   *\n   * @return  {number}             [return description]\n   */\n  public listenerCount(eventName: string): number {\n    return this.listeners.get(eventName)?.length ?? 0\n  }\n\n  /**\n   * Register an event listener with the dispatcher.\n   *\n   * @param {string} event - The event name\n   * @param {Listener | Function} listener - The listener function or object\n   * @returns {() => void} A function to remove the listener\n   */\n  public listen(event: string, listener: IListener | Function): () => void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, [])\n    }\n\n    this.listeners.get(event)!.push(listener)\n\n    // Return a function to remove this listener\n    return () => {\n      const eventListeners = this.listeners.get(event)\n      if (eventListeners) {\n        const index = eventListeners.indexOf(listener)\n        if (index !== -1) {\n          eventListeners.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine if a given event has listeners.\n   *\n   * @param {string} eventName - The event name\n   * @returns {boolean} True if the event has listeners\n   */\n  public hasListeners(eventName: string): boolean {\n    const listeners = this.listeners.get(eventName)\n    return !!listeners && listeners.length > 0\n  }\n\n  /**\n   * Register an event subscriber with the dispatcher.\n   *\n   * @param {Subscriber} subscriber - The subscriber to register\n   */\n  public subscribe(subscriber: ISubscriber): void {\n    subscriber.subscribe(this as IEventDispatcher)\n  }\n\n  /**\n   * Dispatch an event and call the listeners.\n   *\n   * @param {string | Event} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any[]>} Array of results from the listeners\n   */\n  public async dispatch(event: string | IEvent, payload?: any): Promise<any[]> {\n    const eventName = typeof event === 'string' ? event : getEventName(event)\n    const eventObject = typeof event === 'string' ? payload : event\n\n    // Emit to the event stream\n    this.eventSubject.next({\n      name: eventName,\n      payload: eventObject,\n      timestamp: Date.now(),\n    })\n\n    // Emit to the event stream with name and event\n    this.eventStreamSubject.next({\n      name: eventName,\n      event: eventObject,\n    })\n\n    // Check if the event is queueable and we have a queue manager\n    if (this.queueManager && this.isQueueable(eventObject)) {\n      await this.queueEvent(eventObject)\n      return []\n    }\n\n    // Get listeners for this event\n    const eventListeners = this.listeners.get(eventName) || []\n\n    // Execute all listeners and collect results\n    const results: any[] = []\n\n    for (const listener of eventListeners) {\n      try {\n        let result: any\n\n        if (typeof listener === 'function') {\n          result = await listener(eventObject)\n        } else {\n          // Check if the listener is queueable and we have a queue manager\n          if (this.queueManager && this.isQueueable(listener)) {\n            await this.queueListener(listener, eventObject)\n            continue\n          }\n\n          result = await listener.handle(eventObject)\n        }\n\n        results.push(result)\n      } catch (error) {\n        console.error(`Error in event listener for ${eventName}:`, error)\n        throw error\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * Dispatch an event and halt when the first listener returns a non-null response.\n   *\n   * @param {string | Event} event - The event name or object\n   * @param {any} [payload] - The event payload (if event is a string)\n   * @returns {Promise<any>} The first non-null response or null\n   */\n  public async until(event: string | IEvent, payload?: any): Promise<any> {\n    const eventName = typeof event === 'string' ? event : getEventName(event)\n    const eventObject = typeof event === 'string' ? payload : event\n\n    // Emit to the event stream\n    this.eventSubject.next({\n      name: eventName,\n      payload: eventObject,\n      timestamp: Date.now(),\n    })\n\n    // Emit to the event stream with name and event\n    this.eventStreamSubject.next({\n      name: eventName,\n      event: eventObject,\n    })\n\n    // Get listeners for this event\n    const eventListeners = this.listeners.get(eventName) || []\n\n    for (const listener of eventListeners) {\n      try {\n        let result: any\n\n        if (typeof listener === 'function') {\n          result = await listener(eventObject)\n        } else {\n          // We don't queue listeners in until() since we need the result\n          result = await listener.handle(eventObject)\n        }\n\n        if (result !== null && result !== undefined) {\n          return result\n        }\n      } catch (error) {\n        console.error(`Error in event listener for ${eventName}:`, error)\n        throw error\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Remove a set of listeners from the dispatcher.\n   *\n   * @param {string} event - The event name\n   */\n  public forget(event: string): void {\n    this.listeners.delete(event)\n  }\n\n  /**\n   * Remove all listeners from the dispatcher.\n   */\n  public forgetAll(): void {\n    this.listeners.clear()\n  }\n\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  public events(): Observable<EventData> {\n    return this.eventSubject.asObservable()\n  }\n\n  /**\n   * Get an observable of all events with their names\n   *\n   * @returns An observable of events with their names\n   */\n  public getEventStream(): Observable<{ name: string; event: any }> {\n    return this.eventStreamSubject.asObservable()\n  }\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  public ofType(eventName: string): Observable<EventData> {\n    return this.eventSubject.pipe(filter((event) => event.name === eventName))\n  }\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  public ofClass<T extends IEvent>(\n    eventClass: new (...args: any[]) => T,\n  ): Observable<EventData<T>> {\n    const eventName = getEventName(eventClass)\n    return this.ofType(eventName) as Observable<EventData<T>>\n  }\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  public on<T = any>(eventName: string): Observable<T> {\n    return this.ofType(eventName).pipe(map((event) => event.payload as T))\n  }\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  public onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T> {\n    return this.ofClass(eventClass).pipe(map((event) => event.payload as T))\n  }\n\n  /**\n   * Check if an object is queueable.\n   *\n   * @param obj - The object to check\n   * @returns True if the object is queueable\n   * @private\n   */\n  private isQueueable(obj: any): boolean {\n    if (!obj) return false\n\n    // Check if the object implements ShouldQueue interface\n    return typeof obj.shouldQueue === 'function'\n  }\n\n  /**\n   * Queue an event for later processing.\n   *\n   * @param event - The queueable event\n   * @returns Promise resolving when the event is queued\n   * @private\n   */\n  private async queueEvent(event: any): Promise<void> {\n    if (!this.queueManager) {\n      throw new Error('Queue manager is not configured')\n    }\n\n    const delay = event.delay?.() || 0\n    const connection = event.connection?.() || null\n    const queue = event.queue?.() || null\n\n    if (delay > 0) {\n      await this.queueManager.later(delay, event, {}, connection, queue)\n    } else {\n      await this.queueManager.push(event, {}, connection, queue)\n    }\n  }\n\n  /**\n   * Queue a listener for later processing.\n   *\n   * @param listener - The queueable listener\n   * @param event - The event to handle\n   * @returns Promise resolving when the listener is queued\n   * @private\n   */\n  private async queueListener(listener: any, event: IEvent): Promise<void> {\n    if (!this.queueManager) {\n      throw new Error('Queue manager is not configured')\n    }\n\n    const delay = listener.delay?.() || 0\n    const connection = listener.connection?.() || null\n    const queue = listener.queue?.() || null\n\n    if (delay > 0) {\n      await this.queueManager.later(delay, listener, { event }, connection, queue)\n    } else {\n      await this.queueManager.push(listener, { event }, connection, queue)\n    }\n  }\n}\n"]}