{"version":3,"sources":["../../../../node_modules/inversify/es/constants/metadata_keys.js","../../../../node_modules/inversify/es/constants/error_msgs.js","../../../../node_modules/inversify/es/planning/metadata.js","../../../../node_modules/inversify/es/utils/js.js","../../../../node_modules/inversify/es/annotation/decorator_utils.js","../../../../node_modules/inversify/es/annotation/injectable.js","../../../../node_modules/inversify/es/annotation/inject_base.js","../../../../node_modules/inversify/es/annotation/inject.js","../src/constants/metadata.constants.ts","../src/utils/reflection.util.ts","../src/event-bus.ts"],"names":["Metadata","m","EventBus","Subject","filter","map","IEventDispatcher"],"mappings":"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","file":"event-bus.js","sourcesContent":["export var NAMED_TAG = 'named';\r\nexport var NAME_TAG = 'name';\r\nexport var UNMANAGED_TAG = 'unmanaged';\r\nexport var OPTIONAL_TAG = 'optional';\r\nexport var INJECT_TAG = 'inject';\r\nexport var MULTI_INJECT_TAG = 'multi_inject';\r\nexport var TAGGED = 'inversify:tagged';\r\nexport var TAGGED_PROP = 'inversify:tagged_props';\r\nexport var PARAM_TYPES = 'inversify:paramtypes';\r\nexport var DESIGN_PARAM_TYPES = 'design:paramtypes';\r\nexport var POST_CONSTRUCT = 'post_construct';\r\nexport var PRE_DESTROY = 'pre_destroy';\r\nfunction getNonCustomTagKeys() {\r\n    return [\r\n        INJECT_TAG,\r\n        MULTI_INJECT_TAG,\r\n        NAME_TAG,\r\n        UNMANAGED_TAG,\r\n        NAMED_TAG,\r\n        OPTIONAL_TAG,\r\n    ];\r\n}\r\nexport var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();\r\n","export var DUPLICATED_INJECTABLE_DECORATOR = 'Cannot apply @injectable decorator multiple times.';\r\nexport var DUPLICATED_METADATA = 'Metadata key was used more than once in a parameter:';\r\nexport var NULL_ARGUMENT = 'NULL argument';\r\nexport var KEY_NOT_FOUND = 'Key Not Found';\r\nexport var AMBIGUOUS_MATCH = 'Ambiguous match found for serviceIdentifier:';\r\nexport var CANNOT_UNBIND = 'Could not unbind serviceIdentifier:';\r\nexport var NOT_REGISTERED = 'No matching bindings found for serviceIdentifier:';\r\nexport var MISSING_INJECTABLE_ANNOTATION = 'Missing required @injectable annotation in:';\r\nexport var MISSING_INJECT_ANNOTATION = 'Missing required @inject or @multiInject annotation in:';\r\nexport var UNDEFINED_INJECT_ANNOTATION = function (name) {\r\n    return \"@inject called with undefined this could mean that the class \" + name + \" has \" +\r\n        'a circular dependency problem. You can use a LazyServiceIdentifier to  ' +\r\n        'overcome this limitation.';\r\n};\r\nexport var CIRCULAR_DEPENDENCY = 'Circular dependency found:';\r\nexport var NOT_IMPLEMENTED = 'Sorry, this feature is not fully implemented yet.';\r\nexport var INVALID_BINDING_TYPE = 'Invalid binding type:';\r\nexport var NO_MORE_SNAPSHOTS_AVAILABLE = 'No snapshot available to restore.';\r\nexport var INVALID_MIDDLEWARE_RETURN = 'Invalid return type in middleware. Middleware must return!';\r\nexport var INVALID_FUNCTION_BINDING = 'Value provided to function binding must be a function!';\r\nexport var LAZY_IN_SYNC = function (key) { return \"You are attempting to construct '\" + key + \"' in a synchronous way\\n but it has asynchronous dependencies.\"; };\r\nexport var INVALID_TO_SELF_VALUE = 'The toSelf function can only be applied when a constructor is ' +\r\n    'used as service identifier';\r\nexport var INVALID_DECORATOR_OPERATION = 'The @inject @multiInject @tagged and @named decorators ' +\r\n    'must be applied to the parameters of a class constructor or a class property.';\r\nexport var ARGUMENTS_LENGTH_MISMATCH = function () {\r\n    var values = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        values[_i] = arguments[_i];\r\n    }\r\n    return 'The number of constructor arguments in the derived class ' +\r\n        (values[0] + \" must be >= than the number of constructor arguments of its base class.\");\r\n};\r\nexport var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = 'Invalid Container constructor argument. Container options ' +\r\n    'must be an object.';\r\nexport var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = 'Invalid Container option. Default scope must ' +\r\n    'be a string (\"singleton\" or \"transient\").';\r\nexport var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = 'Invalid Container option. Auto bind injectable must ' +\r\n    'be a boolean';\r\nexport var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = 'Invalid Container option. Skip base check must ' +\r\n    'be a boolean';\r\nexport var MULTIPLE_PRE_DESTROY_METHODS = 'Cannot apply @preDestroy decorator multiple times in the same class';\r\nexport var MULTIPLE_POST_CONSTRUCT_METHODS = 'Cannot apply @postConstruct decorator multiple times in the same class';\r\nexport var ASYNC_UNBIND_REQUIRED = 'Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)';\r\nexport var POST_CONSTRUCT_ERROR = function (clazz, errorMessage) { return \"@postConstruct error in class \" + clazz + \": \" + errorMessage; };\r\nexport var PRE_DESTROY_ERROR = function (clazz, errorMessage) { return \"@preDestroy error in class \" + clazz + \": \" + errorMessage; };\r\nexport var ON_DEACTIVATION_ERROR = function (clazz, errorMessage) { return \"onDeactivation() error in class \" + clazz + \": \" + errorMessage; };\r\nexport var CIRCULAR_DEPENDENCY_IN_FACTORY = function (factoryType, serviceIdentifier) {\r\n    return \"It looks like there is a circular dependency in one of the '\" + factoryType + \"' bindings. Please investigate bindings with \" +\r\n        (\"service identifier '\" + serviceIdentifier + \"'.\");\r\n};\r\nexport var STACK_OVERFLOW = 'Maximum call stack size exceeded';\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nvar Metadata = (function () {\r\n    function Metadata(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    Metadata.prototype.toString = function () {\r\n        if (this.key === METADATA_KEY.NAMED_TAG) {\r\n            return \"named: \" + String(this.value).toString() + \" \";\r\n        }\r\n        else {\r\n            return \"tagged: { key:\" + this.key.toString() + \", value: \" + String(this.value) + \" }\";\r\n        }\r\n    };\r\n    return Metadata;\r\n}());\r\nexport { Metadata };\r\n","export function getFirstArrayDuplicate(array) {\r\n    var seenValues = new Set();\r\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n        var entry = array_1[_i];\r\n        if (seenValues.has(entry)) {\r\n            return entry;\r\n        }\r\n        else {\r\n            seenValues.add(entry);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n","import * as ERROR_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { getFirstArrayDuplicate } from '../utils/js';\r\nfunction targetIsConstructorFunction(target) {\r\n    return target.prototype !== undefined;\r\n}\r\nfunction _throwIfMethodParameter(parameterName) {\r\n    if (parameterName !== undefined) {\r\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\r\n    }\r\n}\r\nfunction tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {\r\n    _throwIfMethodParameter(parameterName);\r\n    _tagParameterOrProperty(METADATA_KEY.TAGGED, annotationTarget, parameterIndex.toString(), metadata);\r\n}\r\nfunction tagProperty(annotationTarget, propertyName, metadata) {\r\n    if (targetIsConstructorFunction(annotationTarget)) {\r\n        throw new Error(ERROR_MSGS.INVALID_DECORATOR_OPERATION);\r\n    }\r\n    _tagParameterOrProperty(METADATA_KEY.TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);\r\n}\r\nfunction _ensureNoMetadataKeyDuplicates(metadata) {\r\n    var metadatas = [];\r\n    if (Array.isArray(metadata)) {\r\n        metadatas = metadata;\r\n        var duplicate = getFirstArrayDuplicate(metadatas.map(function (md) { return md.key; }));\r\n        if (duplicate !== undefined) {\r\n            throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + duplicate.toString());\r\n        }\r\n    }\r\n    else {\r\n        metadatas = [metadata];\r\n    }\r\n    return metadatas;\r\n}\r\nfunction _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {\r\n    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);\r\n    var paramsOrPropertiesMetadata = {};\r\n    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {\r\n        paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);\r\n    }\r\n    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];\r\n    if (paramOrPropertyMetadata === undefined) {\r\n        paramOrPropertyMetadata = [];\r\n    }\r\n    else {\r\n        var _loop_1 = function (m) {\r\n            if (metadatas.some(function (md) { return md.key === m.key; })) {\r\n                throw new Error(ERROR_MSGS.DUPLICATED_METADATA + \" \" + m.key.toString());\r\n            }\r\n        };\r\n        for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {\r\n            var m = paramOrPropertyMetadata_1[_i];\r\n            _loop_1(m);\r\n        }\r\n    }\r\n    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);\r\n    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;\r\n    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);\r\n}\r\nfunction createTaggedDecorator(metadata) {\r\n    return function (target, targetKey, indexOrPropertyDescriptor) {\r\n        if (typeof indexOrPropertyDescriptor === 'number') {\r\n            tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);\r\n        }\r\n        else {\r\n            tagProperty(target, targetKey, metadata);\r\n        }\r\n    };\r\n}\r\nfunction _decorate(decorators, target) {\r\n    Reflect.decorate(decorators, target);\r\n}\r\nfunction _param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); };\r\n}\r\nfunction decorate(decorator, target, parameterIndexOrProperty) {\r\n    if (typeof parameterIndexOrProperty === 'number') {\r\n        _decorate([_param(parameterIndexOrProperty, decorator)], target);\r\n    }\r\n    else if (typeof parameterIndexOrProperty === 'string') {\r\n        Reflect.decorate([decorator], target, parameterIndexOrProperty);\r\n    }\r\n    else {\r\n        _decorate([decorator], target);\r\n    }\r\n}\r\nexport { decorate, tagParameter, tagProperty, createTaggedDecorator };\r\n","import * as ERRORS_MSGS from '../constants/error_msgs';\r\nimport * as METADATA_KEY from '../constants/metadata_keys';\r\nfunction injectable() {\r\n    return function (target) {\r\n        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {\r\n            throw new Error(ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);\r\n        }\r\n        var types = Reflect.getMetadata(METADATA_KEY.DESIGN_PARAM_TYPES, target) || [];\r\n        Reflect.defineMetadata(METADATA_KEY.PARAM_TYPES, types, target);\r\n        return target;\r\n    };\r\n}\r\nexport { injectable };\r\n","import { UNDEFINED_INJECT_ANNOTATION } from '../constants/error_msgs';\r\nimport { Metadata } from '../planning/metadata';\r\nimport { createTaggedDecorator } from './decorator_utils';\r\nexport function injectBase(metadataKey) {\r\n    return function (serviceIdentifier) {\r\n        return function (target, targetKey, indexOrPropertyDescriptor) {\r\n            if (serviceIdentifier === undefined) {\r\n                var className = typeof target === 'function' ? target.name : target.constructor.name;\r\n                throw new Error(UNDEFINED_INJECT_ANNOTATION(className));\r\n            }\r\n            return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);\r\n        };\r\n    };\r\n}\r\n","import * as METADATA_KEY from '../constants/metadata_keys';\r\nimport { injectBase } from './inject_base';\r\nvar inject = injectBase(METADATA_KEY.INJECT_TAG);\r\nexport { inject };\r\n","/**\n * Metadata key for event information.\n */\nexport const EVENTS_METADATA_KEY = 'tsevents:event'\n\n/**\n * Metadata key for listener information.\n */\nexport const LISTENERS_METADATA_KEY = 'tsevents:listener'\n\n/**\n * Metadata key for subscriber information.\n */\nexport const SUBSCRIBERS_METADATA_KEY = 'tsevents:subscriber'\n\n/**\n * Metadata key for queueable information.\n */\nexport const QUEUEABLE_METADATA_KEY = 'tsevents:queueable'\n","import 'reflect-metadata'\nimport type { IEvent } from '@pixielity/ts-types'\n\nimport { EVENTS_METADATA_KEY } from '../constants/metadata.constants'\n\n/**\n * Get the event name from an event object or class.\n *\n * @param {Event | Function} event - The event object or class\n * @returns {string} The event name\n */\nexport function getEventName(event: IEvent | Function): string {\n  // If it's an instance with getEventName method, use that\n  if (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as IEvent).getEventName === 'function'\n  ) {\n    return (event as IEvent).getEventName!()\n  }\n\n  // Get the constructor (if it's an instance) or the class itself\n  const target = typeof event === 'object' ? event.constructor : event\n\n  // Check for metadata\n  const metadata = Reflect.getMetadata(EVENTS_METADATA_KEY, target)\n  if (metadata && metadata.name) {\n    return metadata.name\n  }\n\n  // Fallback to class name\n  return target.name\n}\n\n// Registry to track decorated event classes\nconst eventRegistry: Function[] = []\n\n/**\n * Register an event class in the registry.\n * This is called by the Event decorator.\n *\n * @param eventClass - The event class to register\n */\nexport function registerEventClass(eventClass: Function): void {\n  if (!eventRegistry.includes(eventClass)) {\n    eventRegistry.push(eventClass)\n  }\n}\n\n/**\n * Get all registered event classes.\n *\n * @returns {Function[]} Array of event classes\n */\nexport function getEventClasses(): Function[] {\n  return [...eventRegistry]\n}\n\n/**\n * Check if a class is an event.\n *\n * @param {Function} target - The class to check\n * @returns {boolean} True if the class is an event\n */\nexport function isEvent(target: Function): boolean {\n  return Reflect.hasMetadata(EVENTS_METADATA_KEY, target)\n}\n","import { injectable, inject } from 'inversify'\nimport { Subject, type Observable } from 'rxjs'\nimport { filter, map } from 'rxjs/operators'\nimport { IEvent, IEventDispatcher, IEventBus, IEventData, IListener } from '@pixielity/ts-types'\n\nimport { getEventName } from './utils/reflection.util'\n\n/**\n * Event bus for reactive event handling using RxJS\n */\n@injectable()\nexport class EventBus implements IEventBus {\n  /**\n   * Subject for all events\n   */\n  private eventSubject = new Subject<IEventData>()\n\n  /**\n   * The event dispatcher instance\n   */\n  private readonly dispatcher: IEventDispatcher\n\n  /**\n   * Creates a new EventBus instance\n   *\n   * @param dispatcher - The event dispatcher\n   */\n  constructor(\n    @inject(IEventDispatcher.$)\n    dispatcher: IEventDispatcher,\n  ) {\n    this.dispatcher = dispatcher\n    // Subscribe to all events from the dispatcher\n    this.dispatcher.getEventStream().subscribe(({ name, event }: { name: string; event: any }) => {\n      this.eventSubject.next({\n        name,\n        payload: event,\n        timestamp: Date.now(),\n      })\n    })\n  }\n\n  /**\n   * Get an observable of all events\n   *\n   * @returns An observable of all events\n   */\n  public events(): Observable<IEventData> {\n    return this.eventSubject.asObservable()\n  }\n\n  /**\n   * Get an observable of events with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of events with the specified name\n   */\n  public ofType(eventName: string): Observable<IEventData> {\n    return this.eventSubject.pipe(filter((event) => event.name === eventName))\n  }\n\n  /**\n   * Get an observable of events of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of events of the specified class\n   */\n  public ofClass<T extends IEvent>(\n    eventClass: new (...args: any[]) => T,\n  ): Observable<IEventData<T>> {\n    const eventName = getEventName(eventClass)\n    return this.ofType(eventName) as Observable<IEventData<T>>\n  }\n\n  /**\n   * Get an observable of event payloads with a specific name\n   *\n   * @param eventName - The event name\n   * @returns An observable of event payloads with the specified name\n   */\n  public on<T = any>(eventName: string): Observable<T> {\n    return this.ofType(eventName).pipe(map((event) => event.payload as T))\n  }\n\n  /**\n   * Get an observable of event payloads of a specific class\n   *\n   * @param eventClass - The event class\n   * @returns An observable of event payloads of the specified class\n   */\n  public onEvent<T extends IEvent>(eventClass: new (...args: any[]) => T): Observable<T> {\n    return this.ofClass(eventClass).pipe(map((event) => event.payload as T))\n  }\n\n  /**\n   * Subscribe to an event with a listener\n   *\n   * @param event - The event name or class\n   * @param listener - The listener function or object\n   * @returns A function to unsubscribe\n   */\n  public subscribe(\n    event: string | (new (...args: any[]) => IEvent),\n    listener: IListener | Function,\n  ): () => void {\n    const eventName = typeof event === 'string' ? event : getEventName(event)\n    return this.dispatcher.listen(eventName, listener)\n  }\n\n  /**\n   * Subscribe to an event with a typed listener\n   *\n   * @param eventClass - The event class\n   * @param listener - The listener function\n   * @returns A function to unsubscribe\n   */\n  public subscribeToEvent<T extends IEvent>(\n    eventClass: new (...args: any[]) => T,\n    listener: (event: T) => void,\n  ): () => void {\n    return this.dispatcher.listen(getEventName(eventClass), listener)\n  }\n\n  /**\n   * Dispatch an event through the event bus\n   *\n   * @param event - The event to dispatch\n   * @param payload - Optional payload if event is a string\n   * @returns A promise that resolves when the event has been dispatched\n   */\n  public async dispatch(event: string | IEvent, payload?: any): Promise<any[]> {\n    return this.dispatcher.dispatch(event, payload)\n  }\n}\n"]}